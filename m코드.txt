import pandas as pd
import numpy as np

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder

file_path = "C:/Users/Miyoung/Posture/labeled_pose_data_all.csv"
import os
print(os.getcwd())

df = pd.read_csv(file_path)
df.head()

X = df[['shoulder_x', 'shoulder_y', 'hip_x', 'hip_y']]
y = df['posture_label']
# featureì™€ label ë¶„ë¦¬
# xëŠ” YOLOv8ë¡œ ì¶”ì¶œí•œ keypoint ì¤‘ ì‹¤ì œ angleì— ì˜í–¥ì„ ë¯¸ì¹˜ëŠ” ìš”ì†Œ
# yëŠ” ì˜ˆì¸¡í•˜ê³  ì‹¶ì€ ëŒ€ìƒ (ì •ë‹µ ìì„¸ ìƒíƒœ)

label_encoder = LabelEncoder()
label_map = {
    'normal': 0,
    'anterior_tilt': 1,
    'posterior_tilt': 2
}
y_encoded = df['posture_label'].map(label_map).values
# pytorch ë¶„ë¥˜ ëª¨ë¸ì€ í´ë˜ìŠ¤ê°€ ìˆ«ì í˜•íƒœì—¬ì•¼ í•˜ë¯€ë¡œ, yì˜ ë¬¸ìì—´ì„ ìˆ«ìë¡œ ì¸ì½”ë”©
# normalì„ 0, anterior_tiltë¥¼ 1, posterior_tiltë¥¼ 2ë¡œ ì„¤ì •í•¨

X_train, X_test, y_train, y_test = train_test_split(
    X, y_encoded,            # ì „ì²´ ë°ì´í„° X, y
    test_size=0.2,           # 20%ëŠ” í…ŒìŠ¤íŠ¸ ë°ì´í„°ë¡œ ì‚¬ìš©
    stratify=y_encoded,      # ìì„¸ì„ ë¹„ìœ¨ ë™ì¼í•˜ê²Œ ìœ ì§€í•˜ë„ë¡ stratifyë¡œ ì¶”ì¶œ
    random_state=42          # ëœë¤ ë¶„í• ì„ ê³ ì • (ì¬í˜„ ê°€ëŠ¥ì„± ê³ ë ¤)
)

import torch
from torch.utils.data import Dataset

class PostureDataset(Dataset):
    def __init__(self, X, y):# pandas/Numpy ë°ì´í„°ë¥¼ pytorchì—ì„œ í™œìš© ê°€ëŠ¥í•œ tensorë¡œ ë³€í™˜
        self.X = torch.tensor(X.values, dtype=torch.float32)
        self.y = torch.tensor(y, dtype=torch.long)
    
    def __len__(self): # data ê¸¸ì´ 
        return len(self.X)

    def __getitem__(self, idx): # í•˜ë‚˜ì˜ ìƒ˜í”Œ ë¦¬í„´
        return self.X[idx], self.y[idx]

from torch.utils.data import DataLoader

train_dataset = PostureDataset(X_train, y_train)
test_dataset = PostureDataset(X_test, y_test)
# Data ì¸ìŠ¤í„´ìŠ¤ ìƒì„±

train_loader = DataLoader(train_dataset, batch_size=32, shuffle=True)
test_loader = DataLoader(test_dataset, batch_size=32, shuffle=False)
# DataLoader ìƒì„±: datasetì—ì„œ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì™€ì„œ ë°°ì¹˜ ë‹¨ìœ„ë¡œ ë‚˜ëˆ„ê³ , ì„ê³ , ëª¨ë¸ì— ë¶ˆëŸ¬ì˜¤ëŠ” ì—­í•  
# batch_size = 32: ëª¨ë¸ì´ í•œ ë²ˆì— í•™ìŠµí•˜ëŠ” ë°ì´í„° ë¬¶ìŒ í¬ê¸°ë¥¼ ì˜ë¯¸
# epoch: ì „ì²´ í•™ìŠµ ë°ì´í„°ë¥¼ í•œ ë°”í€´ ëŒë©´ì„œ í•™ìŠµí•˜ëŠ” ê²ƒì„ ì˜ë¯¸
# shuffle=true: í•™ìŠµ ë°ì´í„°ë¥¼ ë§¤ epochë§ˆë‹¤ ë¬´ì‘ìœ„ë¡œ ì„ìŒ
# shuffle=false: í…ŒìŠ¤íŠ¸ ë°ì´í„°ëŠ” êµ³ì´ ìˆœì„œë¥¼ ì„ì„ í•„ìš”ëŠ” ì—†ìŒ

import torch.nn as nn
import torch.nn.functional as F

# MLP(Multi-layer perceptron) ëª¨ë¸ ì´ìš©
# 3ê°œì˜ fully-connected layerë¡œ êµ¬ì„±
# ì…ë ¥ (4ì°¨ì›) â”€â†’ [FC1: 64] â”€â†’ ReLU â”€â†’ [FC2: 32] â”€â†’ ReLU â”€â†’ [FC3: 3] â”€â†’ ê²°ê³¼(logits)

class PostureClassifier(nn.Module):
    def __init__(self):
        super(PostureClassifier, self).__init__()
        self.fc1 = nn.Linear(4, 64)   # ì…ë ¥: ì¢Œí‘œ 4ê°œ â†’ ì€ë‹‰ì¸µ 64ê°œ
        # ì¢Œí‘œê°€ ì´ 4ê°œ (shoulder_x,y, hip_x,y)ì´ë¯€ë¡œ ì…ë ¥ì¸µì€ 4
        # 64ê°œ ì°¨ì›ìœ¼ë¡œ í™•ì¥í•˜ì—¬ ë³µì¡í•œ íŠ¹ì§• ì¡°í•©ìœ¼ë¡œ êµ¬í˜„
        self.fc2 = nn.Linear(64, 32)  # ì€ë‹‰ì¸µ 64ê°œ â†’ ì€ë‹‰ì¸µ 32ê°œ
        # ì²« ë²ˆì§¸ layerì—ì„œ í™•ì¥í•œ ì •ë³´ ì¤‘ ì¤‘ìš”í•œ ê²ƒë§Œ ì••ì¶•í•˜ì—¬ ë‹¤ìŒ layerë¡œ ì „ë‹¬
        self.fc3 = nn.Linear(32, 3)   # ì€ë‹‰ì¸µ 32ê°œ â†’ ì¶œë ¥: í´ë˜ìŠ¤ 3ê°œ
        # ìµœì¢…ì ìœ¼ë¡œ normal, anterior_tilt, posterior_tilt ì„¸ ê°€ì§€ í´ë˜ìŠ¤ ì´ë¯€ë¡œ
    
        
    def forward(self, x):
        x = F.relu(self.fc1(x))       # ì²« ë²ˆì§¸ ì€ë‹‰ì¸µ + ReLU
        x = F.relu(self.fc2(x))       # ë‘ ë²ˆì§¸ ì€ë‹‰ì¸µ + ReLU
        return self.fc3(x)            # ì¶œë ¥ì¸µ (softmax ì•ˆ ì¨ë„ ë¨ â†’ CrossEntropyLossì—ì„œ ì²˜ë¦¬ ì˜ˆì •)
        # ReLU(Rectified Linear Unit, ReLI(X) = max(0, x)
        # ë¹„ì„ í˜• í•¨ìˆ˜ë¥¼ í†µí•œ ë³µì¡í•œ ê´€ê³„ í•™ìŠµ ë° gradient vanishing ë¬¸ì œ ì™„í™”

model = PostureClassifier()

# ì†ì‹¤ í•¨ìˆ˜ (ë‹¤ì¤‘ í´ë˜ìŠ¤ ë¶„ë¥˜)
criterion = nn.CrossEntropyLoss()
# softmax ì ìš©, log ì”Œìš°ê¸°, ì •ë‹µ indexì™€ ë¹„êµí•˜ì—¬ loss ê³„ì‚°

# ì˜µí‹°ë§ˆì´ì € (Adamì´ ì•ˆì •ì ì´ê³  í•™ìŠµ ì˜ ë¨)
optimizer = torch.optim.Adam(model.parameters(), lr=0.001)
# ëª¨ë¸ì˜ íŒŒë¼ë¯¸í„°ë¥¼ ì—…ë°ì´íŠ¸ í•´ì¤Œ
# Adam: ì´ì „ì˜ ë³€í™”ëŸ‰ ë° í˜„ì¬ gradientë¥¼ ëª¨ë‘ ê³ ë ¤í•˜ì—¬ ì¡°ì ˆ
# lr: í•™ìŠµë¥ , weight ì—…ë°ì´íŠ¸ í•  ë•Œ ì–¼ë§ˆë‚˜ í¬ê²Œ ì›€ì§ˆì¼ ì§€ ê²°ì •
# ì¼ë°˜ì ìœ¼ë¡œ Adamì—ì„œ ê°€ì¥ ë§ì´ ì“°ì´ëŠ” ê¸°ë³¸ ê°’ì´ 0.001

# GPU ì‚¬ìš© ê°€ëŠ¥í•˜ë©´ GPUë¡œ ëª¨ë¸ ë³´ë‚´ê¸°
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
model.to(device)

num_epochs = 20 # epoch íšŸìˆ˜ ê²°ì •


for epoch in range(num_epochs):
    model.train() # í•™ìŠµ ëª¨ë“œ
    running_loss = 0.0
    correct = 0
    total = 0
    # ì´ˆê¸° ê°’ ì„¤ì • 
    
    for X_batch, y_batch in train_loader:
        X_batch, y_batch = X_batch.to(device), y_batch.to(device)

        # 1. ê¸°ìš¸ê¸° ì´ˆê¸°í™”
        optimizer.zero_grad()
        # ì§ì „ ë¯¸ë¶„ ê²°ê³¼ ì´ˆê¸°í™” (gradient ëˆ„ì ì„ ë°©ì§€)

        # 2. ìˆœì „íŒŒ
        outputs = model(X_batch)
        # ëª¨ë¸ì— ë°ì´í„°ë¥¼ ë„£ê³  ì˜ˆì¸¡ ê²°ê³¼ë¥¼ ë°›ìŒ
        
        # 3. ì†ì‹¤ ê³„ì‚°
        loss = criterion(outputs, y_batch)
        # ì˜ˆì¸¡ê°’ vs ì‹¤ì œê°’ì„ ë¹„êµí•´ì„œ ì†ì‹¤ ê³„ì‚° 
        
        # 4. ì—­ì „íŒŒ
        loss.backward()
        # ì†ì‹¤ì„ ê¸°ì¤€ìœ¼ë¡œ ê° parameterì˜ gradient ê³„ì‚°
        
        # 5. íŒŒë¼ë¯¸í„° ì—…ë°ì´íŠ¸
        optimizer.step()

        # 6. í†µê³„ ê³„ì‚°
        running_loss += loss.item()
        # batchì˜ ì†ì‹¤ ê°’ì„ floatìœ¼ë¡œ êº¼ë‚´ê³ , ì´ë¥¼ running lossì— ë”í•´ì„œ ì „ì²´ epoch ë™ì•ˆì˜ ì†ì‹¤ ì´í•© ê³„ì‚°
        _, predicted = torch.max(outputs, 1)  # ì„¸ ê°€ì§€ì˜ í´ë˜ìŠ¤ ì¤‘ ê°€ì¥ ë†’ì€ ì ìˆ˜ í´ë˜ìŠ¤ ì„ íƒ
        total += y_batch.size(0)
        # í˜„ì¬ ë°°ì¹˜ì˜ ì´ ìƒ˜í”Œ ìˆ˜ë¥¼ totalì— ëˆ„ì 
        correct += (predicted == y_batch).sum().item()
        # ê° ìƒ˜í”Œì´ ì •ë‹µì´ë©´ true, ì•„ë‹ˆë©´ false. ì´ ë•Œ ë§ì¶˜ ê°œìˆ˜ë§Œ ë”í•´ì„œ correctì— ëˆ„ì 
        
    # ì—í­ ê²°ê³¼ ì¶œë ¥
    acc = 100 * correct / total # ì •í™•ë„ ê³„ì‚°
    avg_loss = running_loss / len(train_loader) # í‰ê·  loss ê³„ì‚°
    print(f"Epoch {epoch+1}/{num_epochs} - Loss: {avg_loss:.4f} - Accuracy: {acc:.2f}%")

model.eval()  # í‰ê°€ ëª¨ë“œ ì „í™˜
correct = 0
total = 0

with torch.no_grad():  # í‰ê°€ ì‹œì—” í•™ìŠµì´ í•„ìš” ì—†ìœ¼ë¯€ë¡œ gradient ê³„ì‚° ì•ˆ í•¨. no_grad ì ìš©
    for X_batch, y_batch in test_loader:
        X_batch, y_batch = X_batch.to(device), y_batch.to(device)
        outputs = model(X_batch)
        _, predicted = torch.max(outputs, 1)
        total += y_batch.size(0)
        correct += (predicted == y_batch).sum().item()

test_acc = 100 * correct / total
print(f" í…ŒìŠ¤íŠ¸ ì •í™•ë„: {test_acc:.2f}%")

# í›ˆë ¨ ì •í™•ë„ì™€ í…ŒìŠ¤íŠ¸ ì •í™•ë„ë¥¼ ë¹„êµí•˜ì—¬ ìš°ìˆ˜í•œ ëª¨ë¸ì¸ì§€ í™•ì¸ ê°€ëŠ¥

# Inference pipeline êµ¬ì¶•

from ultralytics import YOLO

yolo_model = YOLO('yolov8n-pose.pt')  # ì‚¬ì „ í•™ìŠµëœ pose ëª¨ë¸

# COCO ê¸°ì¤€: ì–´ê¹¨ (5,6), ì—‰ë©ì´ (11,12)
def extract_shoulder_hip(keypoints):
    try:
        shoulder = (keypoints[5] + keypoints[6]) / 2
        hip = (keypoints[11] + keypoints[12]) / 2
        return np.array([shoulder[0], shoulder[1], hip[0], hip[1]])
    except:
        return None

import torch

# í•™ìŠµëœ PyTorch ëª¨ë¸ ê°ì²´ê°€ ìˆì–´ì•¼ í•¨ â†’ ì˜ˆ: model = torch.load('posture_model.pt')
label_map = {0: 'normal', 1: 'anterior_tilt', 2: 'posterior_tilt'}

def predict_posture(image_path, yolo_model, classifier_model, device='cpu'):
    results = yolo_model.predict(source=image_path, verbose=False)

    if len(results[0].keypoints.xy) == 0:
        return "âŒ ì‚¬ëŒì„ ì¸ì‹í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤."

    keypoints = results[0].keypoints.xy[0].cpu().numpy()
    coords = extract_shoulder_hip(keypoints)

    if coords is None:
        return "âŒ keypoint ì¶”ì¶œ ì‹¤íŒ¨"

    input_tensor = torch.tensor(coords, dtype=torch.float32).unsqueeze(0).to(device)

    classifier_model.eval()
    with torch.no_grad():
        output = classifier_model(input_tensor)
        predicted = torch.argmax(output, dim=1).item()

    return f"âœ… ì˜ˆì¸¡ëœ ìì„¸ ìƒíƒœ: {label_map[predicted]}"

image_path_example = 'C:/Users/Miyoung/Posture/F1_P01_0316_C_P01_0316_cam126_50f.jpg'  # ê²½ë¡œëŠ” ì‹¤ì œ íŒŒì¼ ìœ„ì¹˜ì— ë§ê²Œ ìˆ˜ì •
result = predict_posture(image_path_example, yolo_model, model, device='cpu')
print(result)

import cv2
import matplotlib.pyplot as plt

def visualize_posture(image_path_example, coords, label=None):
    img = cv2.imread(image_path_example)
    if img is None:
        print("ì´ë¯¸ì§€ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨")
        return None

    shoulder = (int(coords[0]), int(coords[1]))
    hip = (int(coords[2]), int(coords[3]))

    # ì‹œê°í™”: ì  + ì„ 
    cv2.circle(img, shoulder, 6, (0, 0, 255), -1)  # ğŸ”´ ì–´ê¹¨
    cv2.circle(img, hip, 6, (0, 255, 0), -1)       # ğŸŸ¢ ì—‰ë©ì´
    cv2.line(img, shoulder, hip, (255, 255, 0), 2)

    

    # RGBë¡œ ë³€í™˜ í›„ ë¦¬í„´
    img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    return img_rgb

def predict_and_visualize(image_path_example, yolo_model, classifier_model, device='cpu'):
    results = yolo_model.predict(source=image_path_example, verbose=False)

    if len(results[0].keypoints.xy) == 0:
        return None, "âŒ ì‚¬ëŒ ì¸ì‹ ì‹¤íŒ¨"

    keypoints = results[0].keypoints.xy[0].cpu().numpy()
    coords = extract_shoulder_hip(keypoints)

    if coords is None:
        return None, "âŒ keypoint ì¶”ì¶œ ì‹¤íŒ¨"

    input_tensor = torch.tensor(coords, dtype=torch.float32).unsqueeze(0).to(device)
    classifier_model.eval()
    with torch.no_grad():
        output = classifier_model(input_tensor)
        predicted = torch.argmax(output, dim=1).item()

    label_map = {0: 'normal', 1: 'anterior_tilt', 2: 'posterior_tilt'}
    label = label_map[predicted]

    vis_img = visualize_posture(image_path_example, coords, label)
    return vis_img, f"ì˜ˆì¸¡ëœ ìì„¸: {label}"

import matplotlib.pyplot as plt
import matplotlib.font_manager as fm
import matplotlib as mpl

# 1. í°íŠ¸ ê²½ë¡œ ì„¤ì • (ìœˆë„ìš° ê¸°ë³¸ í•œê¸€ í°íŠ¸ ì˜ˆì‹œ)
font_path = "C:/Windows/Fonts/malgun.ttf"  # í•œê¸€ ì§€ì›ë˜ëŠ” í°íŠ¸
font_prop = fm.FontProperties(fname=font_path)

# 2. ê¸°ë³¸ í°íŠ¸ ì„¤ì •
mpl.rc('font', family=font_prop.get_name())

# 3. ë§ˆì´ë„ˆ ì›Œë‹ ì—†ì• ê¸°
mpl.rcParams['axes.unicode_minus'] = False

image_path_example = 'C:/Users/Miyoung/Posture/F1_P01_0316_C_P01_0316_cam126_50f.jpg'
vis_img, label = predict_and_visualize(image_path_example, yolo_model, model, device='cpu')

if vis_img is not None:
    plt.imshow(vis_img)
    plt.axis('off')
    plt.title(label)
    plt.show()
else:
    print(label)

import gradio as gr
import cv2
import numpy as np
import tempfile

def gradio_infer(image_np_array):
    try:
        # ìœ íš¨ì„± ê²€ì‚¬
        if image_np_array is None or not isinstance(image_np_array, np.ndarray) or image_np_array.size == 0:
            return None, "âŒ ìœ íš¨í•˜ì§€ ì•Šì€ ì´ë¯¸ì§€ì…ë‹ˆë‹¤. íŒŒì¼ ì—…ë¡œë“œ ë˜ëŠ” ì›¹ìº  ì´¬ì˜ì„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”."

        # ì´ë¯¸ì§€ ì„ì‹œ ì €ì¥
        with tempfile.NamedTemporaryFile(suffix=".jpg", delete=False) as temp:
            cv2.imwrite(temp.name, cv2.cvtColor(image_np_array, cv2.COLOR_RGB2BGR))
            image_path = temp.name

        # ì¶”ë¡  ì‹¤í–‰
        vis_img, label = predict_and_visualize(image_path, yolo_model, model)
        return vis_img, label

    except Exception as e:
        return None, f"âŒ ì˜ˆì¸¡ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {str(e)}"

gr.Interface(
    fn=gradio_infer,
    inputs=gr.Image(type="numpy", label="ì‚¬ì§„ ì—…ë¡œë“œ ë˜ëŠ” ì›¹ìº  ì´¬ì˜"),  # ğŸ“· ë‘˜ ë‹¤ ì§€ì›ë¨
    outputs=[
        gr.Image(label="ì‹œê°í™”ëœ keypoint"),
        gr.Text(label="ì˜ˆì¸¡ëœ ìì„¸ ìƒíƒœ")
    ],
    title="ğŸ“ ìì„¸ ì˜ˆì¸¡ê¸° (YOLO + PyTorch)",
    description="ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•˜ê±°ë‚˜ ì›¹ìº ìœ¼ë¡œ ì´¬ì˜í•´ ìì„¸ë¥¼ ë¶„ì„í•´ë³´ì„¸ìš”."
).launch()
